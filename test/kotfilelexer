# Names: kotfile, .kotfile, Kotfile, .Kotfile, KOTFILE, .KOTFILE
# Version: --kot version

# Parser directive (File format version)
#kot version=1

.os macos linux { let kot.shell =  }
.family windows { let kot.shell =  }
.arch x86_64 { kot.env.AMD64 = true }

# kot.platform.triplet (rust triplets)
# kot.platform.os
# kot.platform.family
# kot.platform.arch

let string =
let string = r##

let cmd =
cmd

.regex regex (gmxUsi) {  }
let m1 = regex.match().0
let m1 = regex.match().result

let all_args = .args { # Cannot do --kot
    -i: arg,  # Since - args can be combined together if these two are combined then
    -v: arg,  # it will take like this -> -iv [I] [V], -vi [V] [I], -iv=[I] [V], -vi=[V] [I]
    -r: flag, # -irv [I] [V]
    -m: flag,
    --release: flag, # -- args cannot be combined.
    --abc: arg(con: $.len() < 23), # Default type is string
    --123: arg(type: int, con: 0..=1),
    ps0: pos(0),
    ps1: pos(1),
    ps2: pos(2, required: true, type: int, con: $ < 0), # Since this is required, then others are also required
}

# Functions can return an object
.fn runner (a, b, c) {
    cmd
    .return { a, b, c }
}

const jump =  # Cannot be rebound

.cmd {
}

.cmd run (args: all_args) {
    if let a = --abc {
    }

    .cmd 23 { # Subcommand (Inherits args from above)
        let p = .parallel (no_fail: true) { # Each command is ran then any vars are added to the object (Do not fail if one of the commands below fails)
            let a =

            .return { a } # Returns an object with a in it.
        }
        # p.a, p.a.stdout, p.a.stderr, p.a.output (stdout and stderr), p.a.code (exit code)

        if a.code == 0 {  }

        .arch aarch64 {  }

        let a = if kot.env.CARGO_HOME { kot.env.CARGO_HOME } else { .none } # .none == null
        let a = if let b = kot.env.CARGO_HOME { b }
        if a {  }
    }
}

lol_lol

# Logic?
# Only logical and compare ops for now. (==, !=, <, >, <=, >=, &&, ||, !)
# let logic = 1 + 2 - 3 * 100 / 10 % 40 && 1
